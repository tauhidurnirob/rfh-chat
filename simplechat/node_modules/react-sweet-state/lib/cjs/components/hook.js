"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createHook = createHook;

var _react = require("react");

var _context = require("../context");

var _createSelector = require("../utils/create-selector");

var EMPTY_SELECTOR = function EMPTY_SELECTOR() {
  return undefined;
};

var DEFAULT_SELECTOR = function DEFAULT_SELECTOR(state) {
  return state;
}; // As we want to subscribe ASAP and useEffect happens on next tick, but
// React currently throws a warning when using useLayoutEffect on the server


var useIsomorphicLayoutEffect = typeof window !== 'undefined' ? _react.useLayoutEffect : _react.useEffect;

function createHook(Store) {
  var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      selector = _ref.selector;

  return function useSweetState(propsArg) {
    var _useContext = (0, _react.useContext)(_context.Context),
        getStore = _useContext.getStore;

    var _getStore = getStore(Store),
        storeState = _getStore.storeState,
        actions = _getStore.actions;

    var hasPropsArg = propsArg !== undefined; // If selector is not null, create a ref to the memoized version of it
    // Otherwise always return same value, as we ignore state

    var stateSelector = selector ? // eslint-disable-next-line react-hooks/rules-of-hooks
    (0, _react.useMemo)(function () {
      return (0, _createSelector.getSelectorInstance)(selector, storeState, hasPropsArg);
    }, [hasPropsArg, storeState]) : selector === null ? EMPTY_SELECTOR : DEFAULT_SELECTOR; // At every render we get fresh state and using recent propsArg
    // we calculate the current value, to be used immediately

    var currentState = stateSelector(storeState.getState(), propsArg);
    (0, _react.useDebugValue)(currentState);
    var triggerUpdate = (0, _react.useState)(function () {
      return currentState;
    })[1];
    var propsRef = (0, _react.useRef)(propsArg);
    propsRef.current = propsArg;
    useIsomorphicLayoutEffect(function () {
      var subscription = {};
      var prevState;

      var onUpdate = function onUpdate(updatedState, updatedStoreState) {
        // if already unmounted ignore the update
        if (!subscription) return; // if scope changed, force a re-render to trigger new subscription

        if (updatedStoreState !== storeState) return triggerUpdate({}); // if selector null we bail out from normal state updates

        if (stateSelector === EMPTY_SELECTOR) return;
        var nextState = stateSelector(updatedState, propsRef.current);

        if (nextState !== prevState) {
          triggerUpdate(function () {
            return nextState;
          });
          prevState = nextState;
        }
      };

      subscription.unsubscribe = storeState.subscribe(onUpdate); // Because we're subscribing in a passive effect,
      // it's possible that an update has occurred between render and effect

      onUpdate(storeState.getState(), storeState);
      return function () {
        // On component unmount we unsubscribe to storeState updates
        subscription.unsubscribe();
        subscription = null;
      };
    }, [storeState]);
    return [currentState, actions];
  };
}