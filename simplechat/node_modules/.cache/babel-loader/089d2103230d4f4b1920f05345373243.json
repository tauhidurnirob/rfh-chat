{"ast":null,"code":"import memoize from './memoize'; // customised version of reselect\n\nexport function createSelector(...funcs) {\n  const resultFunc = funcs.pop();\n  const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n  const memoizedResultFunc = memoize(function () {\n    return resultFunc.apply(null, arguments);\n  }); // this memoisation is optimised for 2 arguments (state, props)\n\n  const selector = memoize(function () {\n    // calculate all dependencies results\n    const params = [];\n\n    for (let i = 0; i < dependencies.length; i++) {\n      params.push(dependencies[i].apply(null, arguments));\n    } // then call the final func with all them as arguments\n\n\n    return memoizedResultFunc.apply(null, params);\n  }, true); // expose so we can create per scope selectors\n  // API compatible with reselect@^4\n\n  selector.resultFunc = resultFunc;\n  selector.dependencies = dependencies;\n  return selector;\n}\nexport function createMemoizedSelector(selector) {\n  const isReselector = typeof selector.resultFunc === 'function' && Array.isArray(selector.dependencies);\n  const dependencies = isReselector ? selector.dependencies : [s => s, (_, p) => p];\n  const resultFunc = isReselector ? selector.resultFunc : selector;\n  return createSelector(dependencies, resultFunc);\n}\nconst cache = new WeakMap();\nexport function getSelectorInstance(selector, storeState, hasProps) {\n  if (!hasProps) {\n    if (!cache.has(storeState)) {\n      cache.set(storeState, new WeakMap());\n    }\n\n    const scopeSelectors = cache.get(storeState);\n\n    if (!scopeSelectors.has(selector)) {\n      scopeSelectors.set(selector, createMemoizedSelector(selector));\n    }\n\n    return scopeSelectors.get(selector);\n  }\n\n  return createMemoizedSelector(selector);\n}","map":{"version":3,"sources":["/Users/nirob/Desktop/rfh-chat/simplechat/node_modules/react-sweet-state/lib/esm/utils/create-selector.js"],"names":["memoize","createSelector","funcs","resultFunc","pop","dependencies","Array","isArray","memoizedResultFunc","apply","arguments","selector","params","i","length","push","createMemoizedSelector","isReselector","s","_","p","cache","WeakMap","getSelectorInstance","storeState","hasProps","has","set","scopeSelectors","get"],"mappings":"AAAA,OAAOA,OAAP,MAAoB,WAApB,C,CAAiC;;AAEjC,OAAO,SAASC,cAAT,CAAwB,GAAGC,KAA3B,EAAkC;AACvC,QAAMC,UAAU,GAAGD,KAAK,CAACE,GAAN,EAAnB;AACA,QAAMC,YAAY,GAAGC,KAAK,CAACC,OAAN,CAAcL,KAAK,CAAC,CAAD,CAAnB,IAA0BA,KAAK,CAAC,CAAD,CAA/B,GAAqCA,KAA1D;AACA,QAAMM,kBAAkB,GAAGR,OAAO,CAAC,YAAY;AAC7C,WAAOG,UAAU,CAACM,KAAX,CAAiB,IAAjB,EAAuBC,SAAvB,CAAP;AACD,GAFiC,CAAlC,CAHuC,CAKnC;;AAEJ,QAAMC,QAAQ,GAAGX,OAAO,CAAC,YAAY;AACnC;AACA,UAAMY,MAAM,GAAG,EAAf;;AAEA,SAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAGR,YAAY,CAACS,MAAjC,EAAyCD,CAAC,EAA1C,EAA8C;AAC5CD,MAAAA,MAAM,CAACG,IAAP,CAAYV,YAAY,CAACQ,CAAD,CAAZ,CAAgBJ,KAAhB,CAAsB,IAAtB,EAA4BC,SAA5B,CAAZ;AACD,KANkC,CAMjC;;;AAGF,WAAOF,kBAAkB,CAACC,KAAnB,CAAyB,IAAzB,EAA+BG,MAA/B,CAAP;AACD,GAVuB,EAUrB,IAVqB,CAAxB,CAPuC,CAiB7B;AACV;;AAEAD,EAAAA,QAAQ,CAACR,UAAT,GAAsBA,UAAtB;AACAQ,EAAAA,QAAQ,CAACN,YAAT,GAAwBA,YAAxB;AACA,SAAOM,QAAP;AACD;AACD,OAAO,SAASK,sBAAT,CAAgCL,QAAhC,EAA0C;AAC/C,QAAMM,YAAY,GAAG,OAAON,QAAQ,CAACR,UAAhB,KAA+B,UAA/B,IAA6CG,KAAK,CAACC,OAAN,CAAcI,QAAQ,CAACN,YAAvB,CAAlE;AACA,QAAMA,YAAY,GAAGY,YAAY,GAAGN,QAAQ,CAACN,YAAZ,GAA2B,CAACa,CAAC,IAAIA,CAAN,EAAS,CAACC,CAAD,EAAIC,CAAJ,KAAUA,CAAnB,CAA5D;AACA,QAAMjB,UAAU,GAAGc,YAAY,GAAGN,QAAQ,CAACR,UAAZ,GAAyBQ,QAAxD;AACA,SAAOV,cAAc,CAACI,YAAD,EAAeF,UAAf,CAArB;AACD;AACD,MAAMkB,KAAK,GAAG,IAAIC,OAAJ,EAAd;AACA,OAAO,SAASC,mBAAT,CAA6BZ,QAA7B,EAAuCa,UAAvC,EAAmDC,QAAnD,EAA6D;AAClE,MAAI,CAACA,QAAL,EAAe;AACb,QAAI,CAACJ,KAAK,CAACK,GAAN,CAAUF,UAAV,CAAL,EAA4B;AAC1BH,MAAAA,KAAK,CAACM,GAAN,CAAUH,UAAV,EAAsB,IAAIF,OAAJ,EAAtB;AACD;;AAED,UAAMM,cAAc,GAAGP,KAAK,CAACQ,GAAN,CAAUL,UAAV,CAAvB;;AAEA,QAAI,CAACI,cAAc,CAACF,GAAf,CAAmBf,QAAnB,CAAL,EAAmC;AACjCiB,MAAAA,cAAc,CAACD,GAAf,CAAmBhB,QAAnB,EAA6BK,sBAAsB,CAACL,QAAD,CAAnD;AACD;;AAED,WAAOiB,cAAc,CAACC,GAAf,CAAmBlB,QAAnB,CAAP;AACD;;AAED,SAAOK,sBAAsB,CAACL,QAAD,CAA7B;AACD","sourcesContent":["import memoize from './memoize'; // customised version of reselect\n\nexport function createSelector(...funcs) {\n  const resultFunc = funcs.pop();\n  const dependencies = Array.isArray(funcs[0]) ? funcs[0] : funcs;\n  const memoizedResultFunc = memoize(function () {\n    return resultFunc.apply(null, arguments);\n  }); // this memoisation is optimised for 2 arguments (state, props)\n\n  const selector = memoize(function () {\n    // calculate all dependencies results\n    const params = [];\n\n    for (let i = 0; i < dependencies.length; i++) {\n      params.push(dependencies[i].apply(null, arguments));\n    } // then call the final func with all them as arguments\n\n\n    return memoizedResultFunc.apply(null, params);\n  }, true); // expose so we can create per scope selectors\n  // API compatible with reselect@^4\n\n  selector.resultFunc = resultFunc;\n  selector.dependencies = dependencies;\n  return selector;\n}\nexport function createMemoizedSelector(selector) {\n  const isReselector = typeof selector.resultFunc === 'function' && Array.isArray(selector.dependencies);\n  const dependencies = isReselector ? selector.dependencies : [s => s, (_, p) => p];\n  const resultFunc = isReselector ? selector.resultFunc : selector;\n  return createSelector(dependencies, resultFunc);\n}\nconst cache = new WeakMap();\nexport function getSelectorInstance(selector, storeState, hasProps) {\n  if (!hasProps) {\n    if (!cache.has(storeState)) {\n      cache.set(storeState, new WeakMap());\n    }\n\n    const scopeSelectors = cache.get(storeState);\n\n    if (!scopeSelectors.has(selector)) {\n      scopeSelectors.set(selector, createMemoizedSelector(selector));\n    }\n\n    return scopeSelectors.get(selector);\n  }\n\n  return createMemoizedSelector(selector);\n}"]},"metadata":{},"sourceType":"module"}