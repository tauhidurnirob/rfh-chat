{"ast":null,"code":"import { useState, useLayoutEffect, useEffect, useRef, useMemo, useContext, useDebugValue } from 'react';\nimport { Context } from '../context';\nimport { getSelectorInstance } from '../utils/create-selector';\n\nconst EMPTY_SELECTOR = () => undefined;\n\nconst DEFAULT_SELECTOR = state => state; // As we want to subscribe ASAP and useEffect happens on next tick, but\n// React currently throws a warning when using useLayoutEffect on the server\n\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nexport function createHook(Store, {\n  selector\n} = {}) {\n  return function useSweetState(propsArg) {\n    const {\n      getStore\n    } = useContext(Context);\n    const {\n      storeState,\n      actions\n    } = getStore(Store);\n    const hasPropsArg = propsArg !== undefined; // If selector is not null, create a ref to the memoized version of it\n    // Otherwise always return same value, as we ignore state\n\n    const stateSelector = selector ? // eslint-disable-next-line react-hooks/rules-of-hooks\n    useMemo(() => getSelectorInstance(selector, storeState, hasPropsArg), [hasPropsArg, storeState]) : selector === null ? EMPTY_SELECTOR : DEFAULT_SELECTOR; // At every render we get fresh state and using recent propsArg\n    // we calculate the current value, to be used immediately\n\n    const currentState = stateSelector(storeState.getState(), propsArg);\n    useDebugValue(currentState);\n    const triggerUpdate = useState(() => currentState)[1];\n    const propsRef = useRef(propsArg);\n    propsRef.current = propsArg;\n    useIsomorphicLayoutEffect(() => {\n      let subscription = {};\n      let prevState;\n\n      const onUpdate = (updatedState, updatedStoreState) => {\n        // if already unmounted ignore the update\n        if (!subscription) return; // if scope changed, force a re-render to trigger new subscription\n\n        if (updatedStoreState !== storeState) return triggerUpdate({}); // if selector null we bail out from normal state updates\n\n        if (stateSelector === EMPTY_SELECTOR) return;\n        const nextState = stateSelector(updatedState, propsRef.current);\n\n        if (nextState !== prevState) {\n          triggerUpdate(() => nextState);\n          prevState = nextState;\n        }\n      };\n\n      subscription.unsubscribe = storeState.subscribe(onUpdate); // Because we're subscribing in a passive effect,\n      // it's possible that an update has occurred between render and effect\n\n      onUpdate(storeState.getState(), storeState);\n      return () => {\n        // On component unmount we unsubscribe to storeState updates\n        subscription.unsubscribe();\n        subscription = null;\n      };\n    }, [storeState]);\n    return [currentState, actions];\n  };\n}","map":{"version":3,"sources":["/Users/nirob/Desktop/rfh-chat/simplechat/node_modules/react-sweet-state/lib/esm/components/hook.js"],"names":["useState","useLayoutEffect","useEffect","useRef","useMemo","useContext","useDebugValue","Context","getSelectorInstance","EMPTY_SELECTOR","undefined","DEFAULT_SELECTOR","state","useIsomorphicLayoutEffect","window","createHook","Store","selector","useSweetState","propsArg","getStore","storeState","actions","hasPropsArg","stateSelector","currentState","getState","triggerUpdate","propsRef","current","subscription","prevState","onUpdate","updatedState","updatedStoreState","nextState","unsubscribe","subscribe"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,eAAnB,EAAoCC,SAApC,EAA+CC,MAA/C,EAAuDC,OAAvD,EAAgEC,UAAhE,EAA4EC,aAA5E,QAAiG,OAAjG;AACA,SAASC,OAAT,QAAwB,YAAxB;AACA,SAASC,mBAAT,QAAoC,0BAApC;;AAEA,MAAMC,cAAc,GAAG,MAAMC,SAA7B;;AAEA,MAAMC,gBAAgB,GAAGC,KAAK,IAAIA,KAAlC,C,CAAyC;AACzC;;;AAGA,MAAMC,yBAAyB,GAAG,OAAOC,MAAP,KAAkB,WAAlB,GAAgCb,eAAhC,GAAkDC,SAApF;AACA,OAAO,SAASa,UAAT,CAAoBC,KAApB,EAA2B;AAChCC,EAAAA;AADgC,IAE9B,EAFG,EAEC;AACN,SAAO,SAASC,aAAT,CAAuBC,QAAvB,EAAiC;AACtC,UAAM;AACJC,MAAAA;AADI,QAEFf,UAAU,CAACE,OAAD,CAFd;AAGA,UAAM;AACJc,MAAAA,UADI;AAEJC,MAAAA;AAFI,QAGFF,QAAQ,CAACJ,KAAD,CAHZ;AAIA,UAAMO,WAAW,GAAGJ,QAAQ,KAAKT,SAAjC,CARsC,CAQM;AAC5C;;AAEA,UAAMc,aAAa,GAAGP,QAAQ,GAAG;AACjCb,IAAAA,OAAO,CAAC,MAAMI,mBAAmB,CAACS,QAAD,EAAWI,UAAX,EAAuBE,WAAvB,CAA1B,EAA+D,CAACA,WAAD,EAAcF,UAAd,CAA/D,CADuB,GACqEJ,QAAQ,KAAK,IAAb,GAAoBR,cAApB,GAAqCE,gBADxI,CAXsC,CAYoH;AAC1J;;AAEA,UAAMc,YAAY,GAAGD,aAAa,CAACH,UAAU,CAACK,QAAX,EAAD,EAAwBP,QAAxB,CAAlC;AACAb,IAAAA,aAAa,CAACmB,YAAD,CAAb;AACA,UAAME,aAAa,GAAG3B,QAAQ,CAAC,MAAMyB,YAAP,CAAR,CAA6B,CAA7B,CAAtB;AACA,UAAMG,QAAQ,GAAGzB,MAAM,CAACgB,QAAD,CAAvB;AACAS,IAAAA,QAAQ,CAACC,OAAT,GAAmBV,QAAnB;AACAN,IAAAA,yBAAyB,CAAC,MAAM;AAC9B,UAAIiB,YAAY,GAAG,EAAnB;AACA,UAAIC,SAAJ;;AAEA,YAAMC,QAAQ,GAAG,CAACC,YAAD,EAAeC,iBAAf,KAAqC;AACpD;AACA,YAAI,CAACJ,YAAL,EAAmB,OAFiC,CAEzB;;AAE3B,YAAII,iBAAiB,KAAKb,UAA1B,EAAsC,OAAOM,aAAa,CAAC,EAAD,CAApB,CAJc,CAIY;;AAEhE,YAAIH,aAAa,KAAKf,cAAtB,EAAsC;AACtC,cAAM0B,SAAS,GAAGX,aAAa,CAACS,YAAD,EAAeL,QAAQ,CAACC,OAAxB,CAA/B;;AAEA,YAAIM,SAAS,KAAKJ,SAAlB,EAA6B;AAC3BJ,UAAAA,aAAa,CAAC,MAAMQ,SAAP,CAAb;AACAJ,UAAAA,SAAS,GAAGI,SAAZ;AACD;AACF,OAbD;;AAeAL,MAAAA,YAAY,CAACM,WAAb,GAA2Bf,UAAU,CAACgB,SAAX,CAAqBL,QAArB,CAA3B,CAnB8B,CAmB6B;AAC3D;;AAEAA,MAAAA,QAAQ,CAACX,UAAU,CAACK,QAAX,EAAD,EAAwBL,UAAxB,CAAR;AACA,aAAO,MAAM;AACX;AACAS,QAAAA,YAAY,CAACM,WAAb;AACAN,QAAAA,YAAY,GAAG,IAAf;AACD,OAJD;AAKD,KA5BwB,EA4BtB,CAACT,UAAD,CA5BsB,CAAzB;AA6BA,WAAO,CAACI,YAAD,EAAeH,OAAf,CAAP;AACD,GAlDD;AAmDD","sourcesContent":["import { useState, useLayoutEffect, useEffect, useRef, useMemo, useContext, useDebugValue } from 'react';\nimport { Context } from '../context';\nimport { getSelectorInstance } from '../utils/create-selector';\n\nconst EMPTY_SELECTOR = () => undefined;\n\nconst DEFAULT_SELECTOR = state => state; // As we want to subscribe ASAP and useEffect happens on next tick, but\n// React currently throws a warning when using useLayoutEffect on the server\n\n\nconst useIsomorphicLayoutEffect = typeof window !== 'undefined' ? useLayoutEffect : useEffect;\nexport function createHook(Store, {\n  selector\n} = {}) {\n  return function useSweetState(propsArg) {\n    const {\n      getStore\n    } = useContext(Context);\n    const {\n      storeState,\n      actions\n    } = getStore(Store);\n    const hasPropsArg = propsArg !== undefined; // If selector is not null, create a ref to the memoized version of it\n    // Otherwise always return same value, as we ignore state\n\n    const stateSelector = selector ? // eslint-disable-next-line react-hooks/rules-of-hooks\n    useMemo(() => getSelectorInstance(selector, storeState, hasPropsArg), [hasPropsArg, storeState]) : selector === null ? EMPTY_SELECTOR : DEFAULT_SELECTOR; // At every render we get fresh state and using recent propsArg\n    // we calculate the current value, to be used immediately\n\n    const currentState = stateSelector(storeState.getState(), propsArg);\n    useDebugValue(currentState);\n    const triggerUpdate = useState(() => currentState)[1];\n    const propsRef = useRef(propsArg);\n    propsRef.current = propsArg;\n    useIsomorphicLayoutEffect(() => {\n      let subscription = {};\n      let prevState;\n\n      const onUpdate = (updatedState, updatedStoreState) => {\n        // if already unmounted ignore the update\n        if (!subscription) return; // if scope changed, force a re-render to trigger new subscription\n\n        if (updatedStoreState !== storeState) return triggerUpdate({}); // if selector null we bail out from normal state updates\n\n        if (stateSelector === EMPTY_SELECTOR) return;\n        const nextState = stateSelector(updatedState, propsRef.current);\n\n        if (nextState !== prevState) {\n          triggerUpdate(() => nextState);\n          prevState = nextState;\n        }\n      };\n\n      subscription.unsubscribe = storeState.subscribe(onUpdate); // Because we're subscribing in a passive effect,\n      // it's possible that an update has occurred between render and effect\n\n      onUpdate(storeState.getState(), storeState);\n      return () => {\n        // On component unmount we unsubscribe to storeState updates\n        subscription.unsubscribe();\n        subscription = null;\n      };\n    }, [storeState]);\n    return [currentState, actions];\n  };\n}"]},"metadata":{},"sourceType":"module"}